import numpy as np
import matplotlib.pyplot as plt
import networkx as nx

# Constants
LOOPS = 4 # Depth of recursion
OMEGA = 117.038

def simulate_multiverse():
    """
    Simulates the tree of branched timelines generated by recursive Möbius jumps.
    """
    G = nx.DiGraph()
    G.add_node("Root (Original)", layer=0, time=0)
    
    # Recursive function to generate branches
    def jump(parent_node, current_layer, current_time, chirality):
        if current_layer >= LOOPS:
            return
            
        # Jump Logic
        # New time = old_time + 2pi (forward coordinated evolution)
        # New chirality = old_chirality * -1 (Flip)
        
        new_time = current_time + 2 * np.pi
        new_chirality = chirality * -1
        
        # Branch Name
        # Based on Chirality (+ = Future, - = Branch)
        chirality_label = "Anti" if new_chirality == -1 else "Iso"
        node_name = f"L{current_layer+1}_{chirality_label}_{round(new_time, 2)}"
        
        G.add_node(node_name, layer=current_layer+1, time=new_time, chirality=new_chirality)
        G.add_edge(parent_node, node_name, label="2π Jump")
        
        # Recursion: The traveler can jump again from this new point
        jump(node_name, current_layer+1, new_time, new_chirality)
        
        # Hypothetical: What if they split? (Quantum Many Worlds)
        # Let's say there's a small probability of a secondary split?
        # For this demo, we'll keep it linear per traveler, but show multiple travelers?
        # No, let's show a single traveler's path generating a singular lineage for now.
        
    jump("Root (Original)", 0, 0, 1)
    
    return G

def plot_multiverse(G):
    pos = {}
    labels = {}
    colors = []
    
    # Custom layout: Layer = X, Chirality = Y (offset)
    for node, data in G.nodes(data=True):
        layer = data['layer']
        # Zig-zag y position based on chirality/layer to show separation
        y = (layer % 2) * 2 - 1 if layer > 0 else 0 
        # Better: Accumulate Y?
        # Let's just use strict layers.
        pos[node] = (layer, 0)
        
        chirality = data.get('chirality', 1)
        labels[node] = f"{node}\n(\u03C7={chirality})"
        
        if chirality == 1:
            colors.append('green') # Original/ISO parity
        else:
            colors.append('red') # Inverted/ANTI parity

    plt.figure(figsize=(12, 6))
    
    # Use built-in layout for better tree look
    pos = nx.spring_layout(G, seed=42) 
    # Force hierarchical layout
    for node, data in G.nodes(data=True):
        pos[node] = (data['layer'], data.get('chirality', 0) * (data['layer']+1))

    nx.draw(G, pos, with_labels=True, labels=labels, node_color=colors, 
            node_size=3000, font_size=8, arrowsize=20)
    
    plt.title("H3 Map: The Recursive Chronology of the Multiverse")
    plt.xlabel("Recursion Depth (Jumps)")
    plt.ylabel("Chirality Phase Space")
    
    plt.savefig('multiverse_map.png')
    print("[ATLAS] Multiverse map generated: multiverse_map.png")

if __name__ == "__main__":
    G = simulate_multiverse()
    plot_multiverse(G)
